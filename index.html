<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pahul's Room</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
            color: white;
        }
        
        #scene-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: grab;
        }
        
        #scene-container:active {
            cursor: grabbing;
        }
        
        #scene-container.clickable-cursor {
            cursor: pointer !important;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #ffffff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #ui-overlay {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 5;
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        #ui-overlay h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #fff;
        }
        
        #ui-overlay p {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 5px;
        }
        
        #controls-panel {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 5;
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .control-button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }
        
        .control-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 15;
            display: none;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            display: none;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        @media (max-width: 768px) {
            #ui-overlay {
                top: 15px;
                left: 15px;
                right: 15px;
                max-width: none;
                padding: 15px;
            }
            
            #ui-overlay h1 {
                font-size: 20px;
            }
            
            #controls-panel {
                bottom: 15px;
                right: 15px;
                left: 15px;
                text-align: center;
            }
            
            .control-button {
                display: inline-block;
                margin: 2px;
            }
        }
        
        .fade-in {
            opacity: 0;
            animation: fadeIn 1s ease-in forwards;
        }
        
        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="scene-container">
        <div id="loading">
            <div class="spinner"></div>
            <div id="loading-text">Loading 3D Model...</div>
            <div id="loading-progress">0%</div>
        </div>
        
        <div id="ui-overlay" class="fade-in">
            <h1>welcome to my study!</h1>
            <p>üñ±Ô∏è Drag to rotate</p>
            <p>üîç Scroll to zoom</p>
            <p>üíª Hold Shift and Pan to move around</p>
            <p>üì± Touch and pinch on mobile</p>
            <p>üëÜ Click objects to interact!</p>
        </div>
        
        <div id="controls-panel" class="fade-in">
            <button class="control-button" onclick="resetCamera()">Reset View</button>
            <button class="control-button" onclick="toggleWireframe()">Wireframe</button>
            <button class="control-button" onclick="highlightClickables()">Show Clickables</button>
        </div>
        
        <div id="tooltip"></div>
        
        <div id="error-message">
            <h3>Error Loading 3D Model</h3>
            <p>Please check that maxpolyroom.glb is in the same folder as this HTML file.</p>
        </div>
    </div>

    <script type="module">
        import { 
            handleLaptopClick, 
            handleBadmintonClick, 
            handleCalendarClick, 
            handleCertificateClick, 
            handlePianoClick 
        } from './interaction-handlers.js';
        
        import * as THREE from 'https://cdn.skypack.dev/three@0.130.1/build/three.module.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.130.1/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.130.1/examples/jsm/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'https://cdn.skypack.dev/three@0.130.1/examples/jsm/loaders/DRACOLoader.js';
        
        let scene, camera, renderer, controls;
        let loadedModel = null;
        let isWireframe = false;
        
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let interactionZones = new Map(); // Maps hitbox objects to their associated objects
        let hitboxObjects = []; // Array of hitbox objects for raycasting
        let hoveredZone = null;
        let highlightedObjects = []; // Currently highlighted objects
        let highlightMaterial = null;
        let originalMaterials = new Map();
        
        const loadingElement = document.getElementById('loading');
        const loadingText = document.getElementById('loading-text');
        const loadingProgress = document.getElementById('loading-progress');
        const errorMessage = document.getElementById('error-message');
        const tooltip = document.getElementById('tooltip');
        const sceneContainer = document.getElementById('scene-container');
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            
            camera = new THREE.PerspectiveCamera(
                50,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            
            camera.position.set(2, 2, 2);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            sceneContainer.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = true;
            controls.minDistance = 3;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI * 0.75;
            
            highlightMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x004400,
                transparent: true,
                opacity: 0.8
            });
            
            setupLighting();
            setupInteraction();
            loadModel();
        }
        
        function setupInteraction() {
            sceneContainer.addEventListener('mousemove', onMouseMove, false);
            sceneContainer.addEventListener('click', onMouseClick, false);
            sceneContainer.addEventListener('touchstart', onTouchStart, false);
            sceneContainer.addEventListener('touchend', onTouchEnd, false);
        }
        
        function onMouseMove(event) {
            event.preventDefault();
            
            const rect = sceneContainer.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(hitboxObjects, true);
            
            if (intersects.length > 0) {
                const intersectedHitbox = intersects[0].object;
                
                if (hoveredZone !== intersectedHitbox) {
                    // Clear previous highlighting
                    clearHighlights();
                    
                    // Set new hovered zone and highlight associated objects
                    hoveredZone = intersectedHitbox;
                    const associatedObjects = interactionZones.get(intersectedHitbox);
                    if (associatedObjects) {
                        highlightObjects(associatedObjects);
                    }
                    
                    sceneContainer.classList.add('clickable-cursor');
                    showTooltip(event, getZoneName(intersectedHitbox));
                }
                
                updateTooltip(event);
            } else {
                if (hoveredZone) {
                    clearHighlights();
                    hoveredZone = null;
                    sceneContainer.classList.remove('clickable-cursor');
                    hideTooltip();
                }
            }
        }
        
        function onMouseClick(event) {
            event.preventDefault();
            
            const rect = sceneContainer.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(hitboxObjects, true);
            
            if (intersects.length > 0) {
                const clickedHitbox = intersects[0].object;
                handleZoneClick(clickedHitbox);
            }
        }
        
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                const rect = sceneContainer.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
            }
        }
        
        function onTouchEnd(event) {
            if (event.changedTouches.length === 1) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(hitboxObjects, true);
                
                if (intersects.length > 0) {
                    const clickedHitbox = intersects[0].object;
                    handleZoneClick(clickedHitbox);
                }
            }
        }
        
        function handleZoneClick(hitbox) {
            const zoneName = getZoneName(hitbox);
            console.log('Clicked on zone:', zoneName);
            
            // Handle different interaction zones
            if (zoneName.includes('Piano Key')) {
                // Handle individual piano key clicks
                handlePianoKeyClick(hitbox);
            } else {
                switch(zoneName) {
                    case 'Laptop':
                        handleLaptopClickLocal();
                        break;
                    case 'Badminton':
                        handleBadmintonClickLocal();
                        break;
                    case 'Calendar':
                        handleCalendarClickLocal();
                        break;
                    case 'Certificate':
                        handleCertificateClickLocal();
                        break;
                    case 'Piano':
                        handlePianoClickLocal();
                        break;
                    default:
                        console.log('Unknown zone:', zoneName);
                }
            }
        }
        
        function handlePianoKeyClick(key) {
            const keyName = key.name;
            console.log('Piano key clicked:', keyName);
            
            // You could play different notes based on the key
            // For now, just show which key was pressed
            const isSharp = keyName.toLowerCase().includes('sharp');
            const note = isSharp ? 'Sharp Note' : 'Natural Note';
            
            // Brief visual feedback
            const originalMaterial = key.material;
            key.material = new THREE.MeshStandardMaterial({
                color: isSharp ? 0x444444 : 0xeeeeee,
                emissive: isSharp ? 0x220000 : 0x002200,
            });
            
            setTimeout(() => {
                key.material = originalMaterial;
            }, 10);
            
            console.log(`Played ${note}: ${keyName}`);
        }
        
        function getZoneName(hitbox) {
            const name = hitbox.name.toLowerCase();
            if (name.includes('laptop_hitbox')) return 'Laptop';
            if (name.includes('badminton_hitbox')) return 'Badminton';
            if (name.includes('calendar_hitbox')) return 'Calendar';
            if (name.includes('certificate_hitbox')) return 'Certificate';
            if (name.includes('piano') && !name.includes('zone')) {
                // Individual piano key
                if (name.includes('sharp')) return 'Piano Key (Sharp)';
                return 'Piano Key';
            }
            return 'Interactive Object';
        }
        
        function highlightObjects(objects) {
            objects.forEach(obj => {
                if (!originalMaterials.has(obj)) {
                    originalMaterials.set(obj, obj.material);
                }
                obj.material = highlightMaterial.clone();
                highlightedObjects.push(obj);
            });
        }
        
        function clearHighlights() {
            highlightedObjects.forEach(obj => {
                if (originalMaterials.has(obj)) {
                    obj.material = originalMaterials.get(obj);
                }
            });
            highlightedObjects = [];
        }
        
        // Interaction handlers for each zone
        function handleLaptopClickLocal() {
            handleLaptopClick();
        }
        
        function handleBadmintonClickLocal() {
            handleBadmintonClick();
        }
        
        function handleCalendarClickLocal() {
            handleCalendarClick();
        }
        
        function handleCertificateClickLocal() {
            handleCertificateClick();
        }
        
        function handlePianoClickLocal() {
            handlePianoClick();
        }
        
        function showTooltip(event, zoneName = 'item') {
            tooltip.textContent = `Click to interact with ${zoneName}`;
            tooltip.style.display = 'block';
            tooltip.style.opacity = '1';
            updateTooltip(event);
        }
        
        function updateTooltip(event) {
            const rect = sceneContainer.getBoundingClientRect();
            tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
            tooltip.style.top = (event.clientY - rect.top - 30) + 'px';
        }
        
        function hideTooltip() {
            tooltip.style.opacity = '0';
            setTimeout(() => {
                tooltip.style.display = 'none';
            }, 300);
        }
        
        function setupInteractionZones(objectsByType) {
            // Map laptop hitboxes to MacBook objects
            objectsByType.laptop_hitbox.forEach(hitbox => {
                interactionZones.set(hitbox, objectsByType.macbook);
                hitboxObjects.push(hitbox);
                hitbox.visible = false;
            });
            
            // Map badminton hitboxes to racquet objects (includes shuttlecocks)
            objectsByType.badminton_hitbox.forEach(hitbox => {
                interactionZones.set(hitbox, objectsByType.racquet);
                hitboxObjects.push(hitbox);
                hitbox.visible = false;
            });
            
            // Map calendar hitboxes to calendar objects
            objectsByType.calendar_hitbox.forEach(hitbox => {
                interactionZones.set(hitbox, objectsByType.calendar);
                hitboxObjects.push(hitbox);
                hitbox.visible = false;
            });
            
            // Certificate objects are their own hitboxes
            objectsByType.certificate_hitbox.forEach(cert => {
                interactionZones.set(cert, [cert]);
                hitboxObjects.push(cert);
            });
            
            // Piano: Set up individual key highlighting + general piano hitbox
            // Individual piano keys
            objectsByType.piano_keys.forEach(key => {
                interactionZones.set(key, [key]); // Each key highlights only itself
                hitboxObjects.push(key);
            });
            
            // General piano hitboxes (for showing piano modal)
            objectsByType.piano_hitbox.forEach(hitbox => {
                const allPianoVisibleObjects = [...objectsByType.piano_visible, ...objectsByType.piano_keys];
                interactionZones.set(hitbox, allPianoVisibleObjects);
                hitboxObjects.push(hitbox);
                hitbox.visible = false;
            });
            
            // Piano visible objects (body, monitor, buttons) remain visible and don't need hitboxes
            
            console.log('Interaction zones setup complete:');
            console.log('- Laptop zones:', objectsByType.laptop_hitbox.length);
            console.log('- MacBook objects:', objectsByType.macbook.length);
            console.log('- Badminton zones:', objectsByType.badminton_hitbox.length);
            console.log('- Racquet objects (including shuttles):', objectsByType.racquet.length);
            console.log('- Calendar zones:', objectsByType.calendar_hitbox.length);
            console.log('- Calendar objects:', objectsByType.calendar.length);
            console.log('- Certificate zones:', objectsByType.certificate_hitbox.length);
            console.log('- Piano keys (individual):', objectsByType.piano_keys.length);
            console.log('- Piano visible objects:', objectsByType.piano_visible.length);
            console.log('- Piano hitboxes:', objectsByType.piano_hitbox.length);
        }
        
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);
            
            const windowLightA = new THREE.PointLight(0xffffff, 1, 0, 2);
            windowLightA.position.set(-1.92, 0.1, -0.5);
            windowLightA.castShadow = true;
            scene.add(windowLightA);

            windowLightA.shadow.mapSize.width = 512;
            windowLightA.shadow.mapSize.height = 512;
            windowLightA.shadow.bias = -0.00005
            windowLightA.shadow.camera.near = 0.5;
            windowLightA.shadow.camera.far = 500;

            const windowLightB = new THREE.PointLight(0xffffff, 1, 0, 2);
            windowLightB.position.set(-1.92, 0.1, 0.5);
            windowLightB.castShadow = true;
            scene.add(windowLightB);

            windowLightB.shadow.mapSize.width = 512;
            windowLightB.shadow.mapSize.height = 512;
            windowLightB.shadow.bias = -0.00005
            windowLightB.shadow.camera.near = 0.5;
            windowLightB.shadow.camera.far = 500;

            const windowLightC = new THREE.PointLight(0xffffff, 1, 0, 2);
            windowLightC.position.set(-1.92, 0.1, 0.1);
            windowLightC.castShadow = true;
            scene.add(windowLightC);

            windowLightC.shadow.mapSize.width = 512;
            windowLightC.shadow.mapSize.height = 512;
            windowLightC.shadow.bias = -0.00005
            windowLightC.shadow.camera.near = 0.5;
            windowLightC.shadow.camera.far = 500;

            const rectLight = new THREE.RectAreaLight(0xffffff, 50, 2, 1);
            rectLight.position.set(-2.2, 0.1, 0.1);
            rectLight.rotation.y = -Math.PI / 2;
            scene.add(rectLight);

            const fillLight = new THREE.DirectionalLight(0x87CEEB, 0.3);
            fillLight.position.set(-5, 3, -5);
            scene.add(fillLight);
            
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.2);
            rimLight.position.set(0, 5, -10);
            scene.add(rimLight);
        }
        
        function loadModel() {
            const loader = new GLTFLoader();
            
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            loader.setDRACOLoader(dracoLoader);
            
            loader.load(
                'maxpolyroom.glb',
                
                function (gltf) {
                    loadedModel = gltf.scene;
                    
                    // First pass: collect all objects by type
                    const objectsByType = {
                        laptop_hitbox: [],
                        macbook: [],
                        badminton_hitbox: [],
                        racquet: [],
                        calendar_hitbox: [],
                        calendar: [],
                        certificate_hitbox: [],
                        piano_hitbox: [],
                        piano_visible: [],
                        piano_keys: []
                    };
                    
                    loadedModel.traverse(function (child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            if (child.material) {
                                child.material.envMapIntensity = 0.8;
                                child.material.side = THREE.DoubleSide;
                            }
                            
                            if (child.name) {
                                const objectName = child.name.toLowerCase();
                                
                                // Categorize objects based on naming conventions
                                if (objectName.includes('laptop_hitbox')) {
                                    objectsByType.laptop_hitbox.push(child);
                                } else if (objectName.includes('macbook')) {
                                    objectsByType.macbook.push(child);
                                } else if (objectName.includes('badminton_hitbox')) {
                                    objectsByType.badminton_hitbox.push(child);
                                } else if (objectName.includes('racquet')) {
                                    objectsByType.racquet.push(child);
                                } else if (objectName.includes('calendar_hitbox')) {
                                    objectsByType.calendar_hitbox.push(child);
                                } else if (objectName.includes('calendar')) {
                                    objectsByType.calendar.push(child);
                                } else if (objectName.includes('certificate_hitbox')) {
                                    objectsByType.certificate_hitbox.push(child);
                                } else if (objectName.includes('piano_zone') && !objectName.includes('piano_zone_')) {
                                    // Pure piano_zone objects are hitboxes
                                    objectsByType.piano_hitbox.push(child);
                                } else if (objectName.includes('piano_zone_')) {
                                    // piano_zone_body, piano_zone_monitor, etc. are visible objects
                                    objectsByType.piano_visible.push(child);
                                } else if (objectName.includes('piano') && !objectName.includes('zone')) {
                                    // Individual piano keys
                                    objectsByType.piano_keys.push(child);
                                }
                            }
                        }
                    });
                    
                    // Set up interaction zones
                    setupInteractionZones(objectsByType);
                    
                    scene.add(loadedModel);
                    console.log(`Set up ${interactionZones.size} interaction zones`);
                    console.log(`Found ${hitboxObjects.length} hitbox objects`);
                    hideLoading();
                },
                
                function (progress) {
                    if (progress.lengthComputable) {
                        const percentComplete = (progress.loaded / progress.total * 100);
                        loadingProgress.textContent = Math.round(percentComplete) + '%';
                    }
                },
                
                function (error) {
                    console.error('Error loading model:', error);
                    showError();
                }
            );
        }
        
        function hideLoading() {
            loadingElement.style.display = 'none';
            
            setTimeout(() => {
                document.getElementById('ui-overlay').style.opacity = '1';
                document.getElementById('controls-panel').style.opacity = '1';
            }, 100);
        }
        
        function showError() {
            loadingElement.style.display = 'none';
            errorMessage.style.display = 'block';
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function resetCamera() {
            controls.reset();
            camera.position.set(2, 2, 2);
            camera.lookAt(0, 0, 0);
        }
        
        function toggleWireframe() {
            if (!loadedModel) return;
            
            isWireframe = !isWireframe;
            
            loadedModel.traverse(function (child) {
                if (child.isMesh && child.material) {
                    child.material.wireframe = isWireframe;
                }
            });
        }
        
        function highlightClickables() {
            if (hitboxObjects.length === 0) {
                alert('No interactive zones found in the model.');
                return;
            }
            
            console.log('Highlighting all interaction zones...');
            
            // Highlight all objects in all interaction zones
            interactionZones.forEach((objects, hitbox) => {
                highlightObjects(objects);
            });
            
            // Remove highlighting after 3 seconds
            setTimeout(() => {
                clearHighlights();
            }, 3000);
        }
        
        window.resetCamera = resetCamera;
        window.toggleWireframe = toggleWireframe;
        window.highlightClickables = highlightClickables;
        
        window.addEventListener('resize', onWindowResize, false);
        
        window.addEventListener('orientationchange', function() {
            setTimeout(onWindowResize, 100);
        });
        
        init();
        animate();
    </script>
</body>
</html>